<?php

namespace MAChitgarha\Json\Components;

use MAChitgarha\Json\Operations\OperationContainer;
use MAChitgarha\Json\Adapters\Interfaces\BaseAdapterInterface;
use MAChitgarha\Json\Adapters\Interfaces\LinterAdapterInterface;
use MAChitgarha\Json\Adapters\Interfaces\DecoderAdapterInterface;
use MAChitgarha\Json\Adapters\Interfaces\EncoderAdapterInterface;
use MAChitgarha\Json\Utils\AdapterUtils;

/**
 * Data related to specific operation.
 */
class _OperationData
{
    /**
     * The provider class name.
     * @var string
     */
    private $providerClass = null;

    /**
     * The adapter class name.
     * @var string
     */
    private $adapterClass = null;

    /**
     * Reference to the adapter instance.
     * @var BaseAdapterInterface
     */
    private $adapterRef = null;

    /**
     * Constructor.
     *
     * @param string $operationName The operation name.
     * @param string $providerClass The provider class name.
     * @param string $adapterClass The adapter class name.
     * @param string $adapterInterface The adapter interface.
     */
    public function __construct(
        string $operationName,
        string $providerClass,
        string $adapterClass,
        string $adapterInterface
    ) {
        $this->providerName = $providerClass;

        $this->adapterName = AdapterUtils::getValidAdapterName(
            $operationName,
            $providerClass,
            $adapterInterface,
            $adapterClass
        );
    }

    /**
     * Sets the adapter reference.
     *
     * @param BaseAdapterInterface $adapter The adapter instance, passed by reference.
     * @return void
     */
    public function setAdapterRef(BaseAdapterInterface &$adapter)
    {
        $this->adapterRef = &$adapter;
    }

    public function &getAdapterRef(): BaseAdapterInterface
    {
        return $this->adapterReference;
    }

    public function getProviderName(): string
    {
        return $this->providerName;
    }

    public function getAdapterName(): string
    {
        return $this->adapterName;
    }
}

/**
 * Provider settings for each operation, along with adapter(s) settings.
 *
 * @todo Sort all operations consistently.
 */
class ProviderSettings
{
    /**
     * List of all adapaters, in the form of an associative array. Keys are generated by
     * {@see self::getProviderAdapterStringPair()}. Initialized inside
     * {@see self::init()}.
     *
     * We should not create a new adapter instance for every operation. It is possible to
     * use one adapter for more than one operation.
     *
     * So, for example, if one provider is used by one adapter class to provide two
     * operations, creating two adapter instances of the same adapter class is really
     * useless. Only one instance of that adapter is needed, as the provider does not
     * change across the operations.
     *
     * As a result, we use adapter-provider string pairs as keys, and adapters as values.
     * Note that, we don't need to hold providers: They live inside adapters. Now, each
     * operation has a reference to its dedicated adapter, which lives here.
     *
     * @var BaseAdapterInterface[]
     */
    private $adapters = [];

    /**
     * Linting operation data.
     * @var _OperationData
     */
    private $lintingData = null;

    /**
     * Encoding operation data.
     * @var _OperationData
     */
    private $encodingData = null;

    /**
     * Decoding operation data.
     * @var _OperationData
     */
    private $decodingData = null;

    /**
     * Constructor.
     */
    public function __construct()
    {
    }

    /**
     * Returns a new instance of the class.
     *
     * @see self::__construct()
     * @param mixed $args Arguemnts forwarded to constructor.
     * @return self
     */
    public static function new(...$args)
    {
        return new static(...$args);
    }

    /**
     * Returns data set of all operations one by one, by reference.
     *
     * @return Generator
     */
    protected function &getOperationDataSet(): \Generator
    {
        yield $this->lintingData;
        yield $this->encodingData;
        yield $this->decodingData;
    }

    /**
     * Returns a distinct string for the pair of an adapter and a provider.
     *
     * @param string $providerClass The provider class name (including its namespace).
     * @param string $adapterClass The adapter class name (including its namespace).
     * @return string
     */
    protected static function getProviderAdapterStringPair(
        string $providerClass,
        string $adapterClass
    ): string {
        return $providerClass . "," . $adapterClass;
    }

    /**
     * Initializes providers and adapters so they can be used.
     *
     * This function should not be called manually.
     *
     * @todo Lock setting new providers after this function gets called.
     * @todo Prevent from calling this method twice.
     * @param mixed $data
     * @return void
     */
    public function init($data)
    {
        foreach ($this->getOperationDataSet() as &$operationData) {
            $providerClass = $operationData->getProviderName();
            $adapterClass = $operationData->getAdapterName();

            $adapterIndex = $this->getProviderAdapterStringPair(
                $providerClass,
                $adapterClass
            );

            if (!\array_key_exists($adapterIndex, $this->adapters)) {
                $this->adapters[$adapterIndex] = new $adapterClass($providerClass, $data);
            }

            $operationData->setAdapter($this->adapters[$adapterIndex]);
        }
    }

    /**
     * Sets the linter provider and its adapter.
     *
     * @param string $providerClass The provider class name.
     * @param string $adapterClass The adapter class name.
     * @return self
     */
    public function setLinter(
        string $providerClass,
        string $adapterClass = AdapterUtils::DEFAULT_ADAPTER
    ): self {
        $this->lintingData = new _OperationData(
            OperationContainer::LINTING,
            $providerClass,
            $adapterClass,
            LinterAdapterInterface::class,
        );

        return $this;
    }

    /**
     * Sets the encoder provider and its adapter.
     *
     * @param string $providerClass The provider class name.
     * @param string $adapterClass The adapter class name.
     * @return self
     */
    public function setEncoder(
        string $providerClass,
        string $adapterClass = AdapterUtils::DEFAULT_ADAPTER
    ): self {
        $this->encodingData = new _OperationData(
            OperationContainer::ENCODING,
            $providerClass,
            $adapterClass,
            EncodingAdapterInterface::class,
        );

        return $this;
    }

    /**
     * Sets the decoder provider and its adapter.
     *
     * @param string $providerClass The provider class name.
     * @param string $adapterClass The adapter class name.
     * @return self
     */
    public function setDecoder(
        string $providerClass,
        string $adapterClass = AdapterUtils::DEFAULT_ADAPTER
    ): self {
        $this->decodingData = new _OperationData(
            OperationContainer::DECODING,
            $providerClass,
            $adapterClass,
            DecodingAdapterInterface::class,
        );

        return $this;
    }

    /**
     * Returns linter adapter.
     *
     * @return LinterAdapterInterface
     */
    public function getLinterAdapter(): LinterAdapterInterface
    {
        return $this->lintingData->getAdapter();
    }

    /**
     * Returns encoder adapter.
     *
     * @return EncoderAdapterInterface
     */
    public function getEncoderAdapter(): EncoderAdapterInterface
    {
        return $this->encodingData->getAdapter();
    }

    /**
     * Returns decoder adapter.
     *
     * @return DecoderAdapterInterface
     */
    public function getDecoderAdapter(): DecoderAdapterInterface
    {
        return $this->decodingData->getAdapter();
    }
}
